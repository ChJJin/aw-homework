// Generated by LiveScript 1.2.0
(function(){
  var Path, View;
  Path = (function(){
    Path.displayName = 'Path';
    var prototype = Path.prototype, constructor = Path;
    function Path(destinationViewName, type){
      this.destinationViewName = destinationViewName;
      this.type = type;
      this.composedPaths = [];
      this.patterns = {};
      this.lastId = this.lastAction = null;
    }
    prototype.createPattern = function(){
      var name, ref$, pattern, path;
      if (this.type === 'list') {
        this.patterns['list'] = '/' + this.destinationViewName;
        this.patterns['reference'] = '/' + this.destinationViewName + '/reference';
      } else if (this.type === 'detail') {
        this.idPlaceHolder = ':' + this.destinationViewName + '_id';
        this.patterns['create'] = '/' + this.destinationViewName + '/create';
        this.patterns['update'] = '/' + this.destinationViewName + '/' + this.idPlaceHolder + '/update';
        this.patterns['view'] = '/' + this.destinationViewName + '/' + this.idPlaceHolder + '/view';
        this.patterns['reference'] = '/' + this.destinationViewName + '/' + this.idPlaceHolder + '/reference';
      } else {
        throw new Error("this '" + this + "type' is not supported yet.");
      }
      if (this.composedPaths.length > 0) {
        for (name in ref$ = this.patterns) {
          pattern = ref$[name];
          this.patterns[name] = pattern + (fn$.call(this));
        }
      }
      function fn$(){
        var i$, ref$, len$, results$ = [];
        for (i$ = 0, len$ = (ref$ = this.composedPaths).length; i$ < len$; ++i$) {
          path = ref$[i$];
          results$.push(path.patterns['reference']);
        }
        return results$;
      }
    };
    prototype.getPath = function(action, id){
      var path;
      if (this.type === 'detail') {
        this.lastId = id || this.lastId;
      }
      this.lastAction = this.patterns[action]
        ? action
        : this.lastAction;
      return path = this.patterns[this.lastAction].replace(this.idPlaceHolder, id);
    };
    return Path;
  }());
  View = (function(){
    View.displayName = 'View';
    var isAllResolved, prototype = View.prototype, constructor = View;
    View.registry = {};
    View.getView = function(docName, viewName, templateName, type){
      if (!this.registry[viewName]) {
        this.registry[viewName] = new View(docName, viewName, templateName, type);
      }
      return this.registry[viewName];
    };
    View.resumeViews = function(views){
      var viewName, view;
      for (viewName in views) {
        view = views[viewName];
        View.registry[viewName] = this.resumeView(view);
      }
      this.createAllViewsPathPattern();
      this.wireViewsLinks();
    };
    View.resumeView = function(view){
      var resumedView;
      view.path = import$(new Path(), view.path);
      resumedView = import$(new View(), view);
      if (Meteor.isClient) {
        resumedView.state = new BP.State(view.name);
      }
      return resumedView;
    };
    View.createAllViewsPathPattern = function(){
      var views, total, resolvedViews, i$, len$, view, j$, ref$, len1$, composedView;
      views = Object.values(this.registry);
      total = views.length;
      resolvedViews = [];
      while (resolvedViews.length !== total) {
        for (i$ = 0, len$ = views.length; i$ < len$; ++i$) {
          view = views[i$];
          if (view !== null && isAllResolved(view.composedViews)) {
            for (j$ = 0, len1$ = (ref$ = Object.values(view.composedViews)).length; j$ < len1$; ++j$) {
              composedView = ref$[j$];
              view.path.composedPaths.push(composedView.path);
            }
            view.path.createPattern();
            resolvedViews.push(view);
            view = null;
          }
        }
      }
    };
    View.wireViewsLinks = function(){
      var docViewPairs, viewName, ref$, view, key$, docName, pairs, list, detail;
      docViewPairs = {};
      for (viewName in ref$ = this.registry) {
        view = ref$[viewName];
        docViewPairs[key$ = view.docName] || (docViewPairs[key$] = {});
        if (view.type === 'list') {
          docViewPairs[view.docName].list = view;
        }
        if (view.type === 'detail') {
          docViewPairs[view.docName].detail = view;
        }
      }
      for (docName in docViewPairs) {
        pairs = docViewPairs[docName];
        list = pairs.list, detail = pairs.detail;
        list.links = {
          create: detail,
          update: detail,
          view: detail,
          'delete': list,
          list: list
        };
        detail.links = {
          previous: detail,
          next: detail,
          'delete': list,
          submit: list
        };
      }
    };
    isAllResolved = function(composedViews){
      var viewName, composedViewOrName;
      for (viewName in composedViews) {
        composedViewOrName = composedViews[viewName];
        if (typeof composedViewOrName === 'object') {
          continue;
        }
        if (!constructor.registry[composedViewOrName]) {
          return false;
        }
        composedViews[viewName] = constructor.registry[composedViewOrName].cloneAsComposed(viewName);
      }
      return true;
    };
    function View(docName, name, templateName, type){
      this.docName = docName;
      this.name = name;
      this.templateName = templateName;
      this.type = type;
      this.path = new Path(this.name, this.type);
      this.isMainNav = false;
      this.composedViews = {};
      this.links = {};
      this.state = null;
    }
    prototype.addComposedView = function(viewName, composedViewName){
      this.composedViews[viewName] = composedViewName;
    };
    prototype.cloneAsComposed = function(newViewName){
      var newView;
      newView = constructor.resumeView(JSON.parse(JSON.stringify(this)));
      newView.name = newViewName;
      newView.isMainNav = false;
      newView.path.destinationViewName = newViewName;
      newView.path.createPattern();
      return newView;
    };
    prototype.getLinkPath = function(action, id){
      var linkToView;
      if (_.isEmpty(this.links)) {
        return null;
      }
      linkToView = this.links[action];
      return linkToView.path.getPath(action, id);
    };
    prototype.updateState = function(action, params){
      var id, viewName, ref$, view, results$ = [];
      if (this.type === 'detail') {
        this.state.set({
          action: action,
          currentId: id = params[this.name + '_id']
        });
        this.state.updatePreNext(id);
      } else if (this.type === 'list') {
        this.state.set({
          action: action
        });
      } else {
        throw new Error("unsupported type: '" + this + "type'.");
      }
      for (viewName in ref$ = this.composedViews) {
        view = ref$[viewName];
        results$.push(view.updateState('reference', params));
      }
      return results$;
    };
    return View;
  }());
  if (typeof module != 'undefined' && module !== null) {
    module.exports = {
      View: View
    };
  } else {
    this.BP.View = View;
  }
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
}).call(this);
